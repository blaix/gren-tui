module Tui exposing
    ( defineProgram
    , Input(..)
    , Program
    )


{-| Model/View/Update on the command line.
-}


import Ansi
import Bytes exposing (Bytes)
import Bytes.Decode
import Bytes.Encode
import Init
import Node
import Stream exposing (Stream)
import Task
import Terminal


-- PROGRAM INIT


{-| Type alias for Tui programs.
-}
type alias Program model msg =
    Node.Program (Model model) (Msg msg)


{-| Record alias for all the functions you need to run a Tui program.

Very similar to a normal Node.Program, except for two special functions:

`view`: Return a string for the current model. gren-tui will print this, and
keep track of how many lines are output so it will only clear those lines when
the output changes. This lets you do things like render progress bars, move
characters around the screen, etc.

`onInput`: Whenever a key is pressed, a message will be sent to your app with a
[`Input`](#Input) value representing the key that was pressed. This lets you
capture input, trigger events on certain key presses, etc.

-}
type alias AppConfig model msg =
    { init : Node.Environment -> Init.Task { model : model, command : Cmd msg }
    , update : msg -> model -> { model : model, command : Cmd msg }
    , subscriptions : model -> Sub msg
    , view : model -> String
    , onInput : (Input -> msg)
    }


{-| Define your Tui program.
-}
defineProgram : AppConfig model msg -> Program model msg
defineProgram appConfig =
    Node.defineProgram
        { init = init appConfig
        , update = update appConfig
        , subscriptions = subscriptions appConfig.subscriptions
        }


type alias Model appModel =
    { stdin : Stream
    , stdout : Stream
    , stderr : Stream
    , appModel : appModel
    , lineCount : Int
    }


init : 
    AppConfig model msg 
    -> Node.Environment
    -> Init.Task { model : Model model, command : Cmd (Msg msg) }
init appConfig env =
    Init.await (appConfig.init env) <| \app ->
        Init.await Terminal.initialize <| \termConfig ->
            let
                appView =
                    appConfig.view app.model

                model =
                    { stdin = env.stdin
                    , stdout = env.stdout
                    , stderr = env.stderr
                    , appModel = app.model
                    , lineCount = 0
                    }
            in
            Node.startProgram
                { model = model
                , command =
                    Cmd.batch
                        [ Cmd.map AppMsg app.command
                        , view model appView
                        , case termConfig of
                            Just config ->
                                Terminal.setStdInRawMode config.permission True
                            Nothing ->
                                -- TODO: proper error handling for not being in interactive term
                                Stream.sendLine env.stderr "Not running in interactive terminal."
                        ]
                }


-- UPDATE


type Msg appMsg
    = GotStdin Bytes
    | AppMsg appMsg
    | LineCountUpdated Int


update : 
    AppConfig appModel appMsg 
    -> Msg appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appMsg) }
update appConfig msg model =
    case msg of
        GotStdin bytes ->
            appUpdate
                appConfig 
                (appConfig.onInput <| bytesToInput bytes)
                model

        LineCountUpdated n ->
            { model = { model | lineCount = n }
            , command = Cmd.none
            }

        AppMsg appMsg ->
            appUpdate appConfig appMsg model


appUpdate :
    AppConfig appModel appMsg 
    -> appMsg
    -> Model appModel
    -> { model : Model appModel, command : Cmd (Msg appMsg) }
appUpdate appConfig appMsg model =
    let
        appUpdateResult =
            appConfig.update appMsg model.appModel

        appView =
            appConfig.view appUpdateResult.model

        newModel =
            { model | appModel = appUpdateResult.model }
    in
    { model = newModel
    , command =
        Cmd.batch
            [ view newModel appView
            , Cmd.map AppMsg appUpdateResult.command
            ]
    }


subscriptions : (model -> Sub msg) -> Model model -> Sub (Msg msg)
subscriptions appSubs model =
    Sub.batch
        [ Sub.map AppMsg (appSubs model.appModel)
        , Stream.listen model.stdin GotStdin
        ]


-- VIEW


view : Model model -> String -> Cmd (Msg msg)
view model appViewResult =
    Cmd.batch
        [ resetScreen model
        , Stream.sendLine model.stdout appViewResult
        , appViewResult
            |> countLines
            |> Task.succeed
            |> Task.perform LineCountUpdated
        ]


resetScreen : Model model -> Cmd (Msg msg)
resetScreen model =
    Cmd.batch
        [ Stream.sendString model.stdout <| Ansi.moveUpLines model.lineCount
        , Stream.sendString model.stdout <| Ansi.clearScreen Ansi.Down
        ]


-- INPUT


type Input
    = KeyChar String
    | Tab
    | Space
    | Return
    | ArrowUp
    | ArrowDown
    | ArrowLeft
    | ArrowRight
    | UnknownInput


bytesToInput : Bytes -> Input
bytesToInput bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)
        |> Maybe.map stringToInput
        |> Maybe.withDefault UnknownInput


stringToInput : String -> Input
stringToInput string =
    if string == Ansi.arrowUp then
        ArrowUp
    else if string == Ansi.arrowDown then
        ArrowDown
    else if string == Ansi.arrowRight then
        ArrowRight
    else if string == Ansi.arrowLeft then
        ArrowLeft
    else if string == "\t" then
        Tab
    else if string == "\r" then
        Return
    else if string == " " then
        Space
    else
        KeyChar string


-- UTIL


countLines : String -> Int
countLines string =
    string
        |> String.lines
        |> Array.length
