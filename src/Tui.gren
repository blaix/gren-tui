module Tui exposing
    ( defineProgram
    , Input(..)
    , Program
    )


import Bytes exposing (Bytes)
import Bytes.Decode
import EscapeSequence as Esc
import Init
import Node
import Stream exposing (Stream)
import Task
import Terminal


-- PROGRAM INIT


type alias Program model msg =
    Node.Program (Model model) (Msg msg)


type alias AppConfig model msg =
    { init : Node.Environment -> Init.Task { model : model, command : Cmd msg }
    , update : msg -> model -> { model : model, command : Cmd msg }
    , subscriptions : model -> Sub msg
    , view : model -> String
    , onInput : (Input -> msg)
    }

defineProgram : AppConfig model msg -> Program model msg
defineProgram appConfig =
    Node.defineProgram
        { init = init appConfig
        , update = update appConfig
        , subscriptions = subscriptions appConfig.subscriptions
        }


type alias Model appModel =
    { stdin : Stream
    , stdout : Stream
    , stderr : Stream
    , appModel : appModel
    , lineCount : Int
    }


init : 
    AppConfig model msg 
    -> Node.Environment
    -> Init.Task { model : Model model, command : Cmd (Msg msg) }
init appConfig env =
    Init.await (appConfig.init env) <| \app ->
        Init.await Terminal.initialize <| \termConfig ->
            let
                appView =
                    appConfig.view app.model

                model =
                    { stdin = env.stdin
                    , stdout = env.stdout
                    , stderr = env.stderr
                    , appModel = app.model
                    , lineCount = 0
                    }
            in
            Node.startProgram
                { model = model
                , command =
                    Cmd.batch
                        [ Cmd.map AppMsg app.command
                        , view model appView
                        , case termConfig of
                            Just config ->
                                Terminal.setStdInRawMode config.permission True
                            Nothing ->
                                -- TODO: proper error handling for not being in interactive term
                                Stream.sendLine env.stderr "Not running in interactive terminal."
                        ]
                }


-- UPDATE


type Msg appMsg
    = GotStdin Bytes
    | AppMsg appMsg
    | LineCountUpdated Int


update : 
    AppConfig model msg 
    -> Msg msg
    -> Model model
    -> { model : Model model, command : Cmd (Msg msg) }
update appConfig msg model =
    case msg of
        GotStdin bytes ->
            let
                input =
                    bytes
                        |> bytesToString
                        -- TODO: use Char instead of String for KeyChar value
                        -- and verify it's actually a character and not a ctrl-character or something
                        |> Maybe.map KeyChar
                        |> Maybe.withDefault UnknownInput

                appResult =
                    appConfig.update
                        (appConfig.onInput input)
                        model.appModel
            in
            { model = { model | appModel = appResult.model }
            , command = Cmd.map AppMsg appResult.command
            }

        LineCountUpdated n ->
            { model = { model | lineCount = n }
            , command = Cmd.none
            }

        AppMsg appMsg ->
            let
                appUpdate =
                    appConfig.update appMsg model.appModel

                appView =
                    appConfig.view appUpdate.model

                newModel =
                    { model | appModel = appUpdate.model }
            in
            { model = newModel
            , command =
                Cmd.batch
                    [ view newModel appView
                    , Cmd.map AppMsg appUpdate.command
                    ]
            }


subscriptions : (model -> Sub msg) -> Model model -> Sub (Msg msg)
subscriptions appSubs model =
    Sub.batch
        [ Sub.map AppMsg (appSubs model.appModel)
        , Stream.listen model.stdin GotStdin
        ]


-- VIEW


view : Model model -> String -> Cmd (Msg msg)
view model appViewResult =
    Cmd.batch
        [ resetScreen model
        , Stream.sendLine model.stdout appViewResult
        , appViewResult
            |> countLines
            |> Task.succeed
            |> Task.perform LineCountUpdated
        ]


resetScreen : Model model -> Cmd (Msg msg)
resetScreen model =
    Cmd.batch
        [ Stream.sendString model.stdout <| Esc.moveUpLines model.lineCount
        , Stream.sendString model.stdout <| Esc.clearScreen Esc.Down
        ]


-- INPUT


type Input
    = KeyChar String
    | UnknownInput


bytesToString : Bytes -> Maybe String
bytesToString bytes =
    bytes
        |> Bytes.width
        |> Bytes.Decode.string
        |> (\decoder -> Bytes.Decode.decode decoder bytes)


-- UTIL


countLines : String -> Int
countLines string =
    string
        |> String.lines
        |> Array.length
