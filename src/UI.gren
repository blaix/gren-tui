module UI exposing
    ( Element
    , toString

    -- Layout
    , row
    , column
    , text
    , bordered
    )


import Ansi
import Array2d exposing (Array2d)
import Internal
import UI.Attribute as Attribute exposing (Attribute)
import UI.Border exposing (Border)


type Element
    = Row { attrs : Array Attribute, children : Array Element }
    | Col { attrs : Array Attribute, children : Array Element }
    | Bordered { attrs : Array Attribute, child : Element, border : Border }
    | Text String


row : Array Attribute -> Array Element -> Element
row attrs children =
    Row { attrs = attrs, children = children }


column : Array Attribute -> Array Element -> Element
column attrs children =
    Col { attrs = attrs, children = children }


text : Array Attribute -> String -> Element
text attrs content =
    content
        |> String.split "\n"
        |> Array.map Text
        |> column attrs


bordered : Border -> Element -> Element
bordered border element = 
    Bordered { attrs = [], child = element, border = border }


mergeAttributes : Array Attribute -> Element -> Element
mergeAttributes parentAttrs element =
    case element of
        Row { attrs, children } ->
            Row 
                { attrs = parentAttrs ++ attrs
                , children =
                    children
                        |> Array.map (mergeAttributes (parentAttrs ++ attrs))
                }

        Col { attrs, children } ->
            Col 
                { attrs = parentAttrs ++ attrs
                , children =
                    children
                        |> Array.map (mergeAttributes (parentAttrs ++ attrs))
                }

        Bordered { attrs, child, border } ->
            Bordered
                { attrs = parentAttrs ++ attrs
                , child =
                    mergeAttributes (parentAttrs ++ attrs) child
                , border = border
                }

        Text content ->
            Text content


toString : Element -> String
toString element =
    element
        |> mergeAttributes []
        |> toStringInternal []


toStringInternal : Array Attribute -> Element -> String
toStringInternal parentAttrs element =
    -- NOTE: Attributes are already merged with their parents.
    -- The parentAttrs param only matters if we're adding net new strings
    -- (e.g. adding borders).

    case element of
        Row { attrs, children } ->
            children
                |> Array.map (toStringInternal attrs)
                |> joinHorizontal attrs
        
        Col { attrs, children } ->
            children
                |> Array.map (toStringInternal attrs)
                |> joinVertical attrs

        Bordered { attrs, child, border } ->
            let
                contents =
                    toStringInternal attrs child

                lines =
                    String.lines contents

                width =
                    maxWidth lines

                top =
                    Attribute.applyAll parentAttrs <|
                        border.topLeft ++ (String.repeat width border.top) ++ border.topRight

                bottom =
                    Attribute.applyAll parentAttrs <|
                        border.bottomLeft ++ (String.repeat width border.bottom) ++ border.bottomRight

                left =
                    Attribute.applyAll parentAttrs border.left

                right =
                    Attribute.applyAll parentAttrs border.right
            in
            lines
                |> Array.map (\l -> left ++ l ++ right)
                |> Array.pushFirst top
                |> Array.pushLast bottom
                |> String.join "\n"

        Text content ->
            content


joinHorizontal : Array Attribute -> Array String -> String
joinHorizontal attrs columns =
    let
        colsOfLines : Array2d String
        colsOfLines =
            columns
                |> Array.map (String.split "\n")

        maxLines : Int
        maxLines =
            colsOfLines
                |> Array.map Array.length
                |> Array.maximum
                |> Maybe.withDefault 0

        normalized : Array2d String
        normalized =
            colsOfLines
                |> Array.map (padLines maxLines)

        {- Turn the array of columns that look like this:

            [ ["a", "b"] -- column 1
            , ["1", "2"] -- column 2
            ]

        Into an array of rows that look like this:

            [ ["a", "1"] -- row 1
            , ["b", "2"] -- row 2
            ]

        For easier joining of the final output.
        -}
        zipped : Array2d String
        zipped =
            Array.initialize maxLines 0
                (\x ->
                    Array.initialize (Array.length normalized) 0
                        (\y ->
                            Array2d.get { x = x, y = y } normalized
                                |> Maybe.withDefault ""
                        )
                )
    in
    zipped
        |> Array2d.map (Attribute.applyAll attrs)
        |> Array.map (String.join "")
        |> String.join "\n"

joinVertical : Array Attribute -> Array String -> String
joinVertical attrs rows =
    rows
        |> Array.map (padRight (maxWidth rows))
        |> Array.map (Attribute.applyAll attrs)
        |> String.join "\n"


maxWidth : Array String -> Int
maxWidth lines =
    lines
        |> Array.map (String.split "\n")
        |> Array.flatten
        |> Array.map Ansi.width
        |> Array.maximum
        |> Maybe.withDefault 0


{-| Given an array of lines, return an array with at least `height` number of
lines, each having the same number of characters, using spaces for padding.
-}
padLines : Int -> Array String -> Array String
padLines height lines =
    let
        heightDiff =
            height - (Array.length lines)

        extraLines =
            Array.repeat heightDiff ""
    in
    lines
        |> Array.append extraLines
        |> Array.map (padRight (maxWidth lines))


{-| Padd a string with spaces until it is the given length.
Accounts for ansi sequences and ensures bg extends over the added spaces.
-}
padRight : Int -> String -> String
padRight width string =
    let
        diff =
            width - Ansi.width string

        parts =
            Internal.bgHelper string
    in
    if diff > 0 then
        parts.string ++ (String.repeat diff " ") ++ parts.suffix
    else
        string
